use super::*;
use crate::editor::StoryNode;

#[test]
fn test_workbench_initialization() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    // Assert default state
    assert_eq!(workbench.mode, EditorMode::Editor);
    assert!(workbench.node_graph.nodes.is_empty());
    assert!(!workbench.is_playing);

    // Add dummy track
    let mut track = visual_novel_engine::Track::new(
        visual_novel_engine::EntityId::new(1),
        visual_novel_engine::PropertyType::PositionX,
    );
    track
        .add_keyframe(visual_novel_engine::Keyframe::new(
            100,
            0,
            visual_novel_engine::Easing::Linear,
        ))
        .unwrap();
    workbench.timeline.add_track(track).unwrap();

    // Test simple update
    workbench.is_playing = true;
    workbench.update(1);
    assert!(
        workbench.current_time > 0.0,
        "Time should advance when playing"
    );
}

#[test]
fn workbench_can_apply_and_revert_quick_fix() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 120.0),
    );
    workbench.node_graph.connect(start, dialogue);

    let _ = workbench.run_dry_validation();
    let issue_index = workbench
        .validation_issues
        .iter()
        .position(|issue| issue.code == LintCode::EmptySpeakerName)
        .expect("expected EmptySpeakerName issue");

    workbench
        .apply_issue_fix(issue_index, "dialogue_fill_speaker")
        .expect("speaker fix should be applied");
    let Some(StoryNode::Dialogue { speaker, .. }) = workbench.node_graph.get_node(dialogue) else {
        panic!("expected dialogue node");
    };
    assert_eq!(speaker, "Narrator");
    assert!(!workbench.quick_fix_audit.is_empty());

    assert!(workbench.revert_last_fix());
    let Some(StoryNode::Dialogue { speaker, .. }) = workbench.node_graph.get_node(dialogue) else {
        panic!("expected dialogue node");
    };
    assert_eq!(speaker, "");
}

#[test]
fn workbench_diagnostic_report_json_contains_bilingual_fields() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);
    workbench.validation_issues.push(
        crate::editor::validator::LintIssue::error(
            Some(7),
            crate::editor::ValidationPhase::Graph,
            crate::editor::LintCode::EmptySpeakerName,
            "Speaker is empty",
        )
        .with_event_ip(Some(3)),
    );

    let payload = workbench
        .diagnostic_report_json()
        .expect("report json should be built");
    let parsed: serde_json::Value = serde_json::from_str(&payload).expect("valid json");
    let issue = &parsed["issues"][0];

    assert_eq!(issue["diagnostic_id"], "GRAPH:VAL_SPEAKER_EMPTY:7:3");
    assert!(issue["message_es"].as_str().is_some());
    assert!(issue["message_en"].as_str().is_some());
    assert!(issue["why_failed_es"].as_str().is_some());
    assert!(issue["why_failed_en"].as_str().is_some());
}

#[test]
fn workbench_reports_missing_localization_keys() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);
    workbench
        .localization_catalog
        .insert_locale_table("en", std::collections::BTreeMap::new());
    workbench.player_locale = "en".to_string();

    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "loc:speaker.narrator".to_string(),
            text: "loc:dialogue.intro".to_string(),
        },
        egui::pos2(0.0, 120.0),
    );
    workbench.node_graph.connect(start, dialogue);

    let _ = workbench.run_dry_validation();
    assert!(workbench
        .validation_issues
        .iter()
        .any(|issue| issue.message.contains("[i18n] Missing key")));
}

#[test]
fn workbench_requires_preview_for_structural_fix() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "Narrador".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 0.0),
    );
    assert!(workbench
        .node_graph
        .get_node(dialogue)
        .is_some_and(|node| matches!(node, StoryNode::Dialogue { .. })));

    let _ = workbench.run_dry_validation();
    let issue_index = workbench
        .validation_issues
        .iter()
        .position(|issue| issue.code == LintCode::MissingStart)
        .expect("expected MissingStart issue");

    workbench
        .prepare_structural_fix_confirmation(issue_index, "graph_add_start")
        .expect("preview for structural fix should be prepared");
    assert!(workbench.show_fix_confirm);
    assert!(workbench.pending_structural_fix.is_some());
    assert!(
        !workbench
            .node_graph
            .nodes()
            .any(|(_, node, _)| matches!(node, StoryNode::Start)),
        "structural fix must not apply before explicit confirmation"
    );

    workbench
        .apply_pending_structural_fix()
        .expect("confirmed structural fix should apply");
    assert!(
        workbench
            .node_graph
            .nodes()
            .any(|(_, node, _)| matches!(node, StoryNode::Start)),
        "start node should exist after confirmed structural fix"
    );
}

#[test]
fn report_export_import() {
    let config = VnConfig::default();
    let mut source = EditorWorkbench::new(config.clone());
    source.validation_issues.push(
        crate::editor::validator::LintIssue::warning(
            Some(12),
            crate::editor::ValidationPhase::Graph,
            crate::editor::LintCode::ChoiceOptionUnlinked,
            "Choice option 2 has no outgoing connection",
        )
        .with_event_ip(Some(4))
        .with_edge(Some(12), Some(21))
        .with_asset_path(Some("bg/room.png".to_string())),
    );
    source.selected_issue = Some(0);
    source.selected_node = Some(12);
    source.diagnostic_language = crate::editor::DiagnosticLanguage::En;

    let payload = source
        .diagnostic_report_json()
        .expect("report should serialize");

    let mut target = EditorWorkbench::new(config);
    target
        .apply_diagnostic_report_json(&payload)
        .expect("report should import");

    assert_eq!(target.validation_issues.len(), 1);
    let issue = &target.validation_issues[0];
    assert_eq!(issue.code, crate::editor::LintCode::ChoiceOptionUnlinked);
    assert_eq!(issue.edge_from, Some(12));
    assert_eq!(issue.edge_to, Some(21));
    assert_eq!(issue.asset_path.as_deref(), Some("bg/room.png"));
    assert_eq!(target.selected_issue, Some(0));
    assert_eq!(target.selected_node, Some(12));
}

#[test]
fn deep_link_to_graph_entities() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);
    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let scene = workbench.node_graph.add_node(
        StoryNode::Scene {
            profile: None,
            background: Some("bg/forest.png".to_string()),
            music: None,
            characters: Vec::new(),
        },
        egui::pos2(0.0, 120.0),
    );
    workbench.node_graph.connect(start, scene);
    let _ = workbench.sync_graph_to_script();

    let report = serde_json::json!({
        "schema": "vneditor.diagnostic_report.v1",
        "language": "es",
        "player_locale": "es",
        "selected_node": null,
        "selected_issue": 0,
        "issues": [
            {
                "phase": "GRAPH",
                "code": "VAL_ASSET_NOT_FOUND",
                "severity": "error",
                "node_id": null,
                "event_ip": null,
                "edge_from": null,
                "edge_to": null,
                "asset_path": "bg/forest.png",
                "message_es": "Asset faltante",
                "message_en": "Missing asset"
            }
        ]
    });
    let payload = serde_json::to_string(&report).expect("serialize report");
    workbench
        .apply_diagnostic_report_json(&payload)
        .expect("imported report should be valid");

    assert_eq!(workbench.selected_issue, Some(0));
    assert_eq!(workbench.selected_node, Some(scene));
}

#[test]
fn workbench_autofix_selected_issue_applies_specific_fix() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 120.0),
    );
    workbench.node_graph.connect(start, dialogue);
    let _ = workbench.run_dry_validation();

    let issue_index = workbench
        .validation_issues
        .iter()
        .position(|issue| issue.code == LintCode::EmptySpeakerName)
        .expect("expected EmptySpeakerName issue");

    let outcome = workbench
        .apply_best_fix_for_issue(issue_index, false)
        .expect("specific autofix should apply");
    assert!(outcome.contains("dialogue_fill_speaker"));

    let Some(StoryNode::Dialogue { speaker, .. }) = workbench.node_graph.get_node(dialogue) else {
        panic!("expected dialogue node");
    };
    assert_eq!(speaker, "Narrator");
}

#[test]
fn workbench_autofix_batch_can_prepare_and_apply_complete_mode() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 0.0),
    );
    assert!(workbench
        .node_graph
        .get_node(dialogue)
        .is_some_and(|node| matches!(node, StoryNode::Dialogue { .. })));

    let _ = workbench.run_dry_validation();
    let planned = workbench
        .prepare_autofix_batch_confirmation(true)
        .expect("autofix batch should be planned");
    assert!(planned >= 1);
    assert!(workbench.show_fix_confirm);
    assert!(workbench.pending_auto_fix_batch.is_some());

    let result = workbench
        .apply_pending_autofix_batch()
        .expect("autofix batch should apply");
    assert!(result.applied >= 1);

    assert!(workbench
        .node_graph
        .nodes()
        .any(|(_, node, _)| matches!(node, StoryNode::Start)));
    let fixed_speaker = workbench.node_graph.nodes().find_map(|(id, node, _)| {
        if *id == dialogue {
            if let StoryNode::Dialogue { speaker, .. } = node {
                return Some(speaker.clone());
            }
        }
        None
    });
    assert_eq!(fixed_speaker.as_deref(), Some("Narrator"));
}

#[test]
fn autofix_rollback() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Linea".to_string(),
        },
        egui::pos2(0.0, 100.0),
    );
    workbench.node_graph.connect(start, dialogue);
    let _ = workbench.run_dry_validation();

    let idx = workbench
        .validation_issues
        .iter()
        .position(|issue| issue.code == LintCode::EmptySpeakerName)
        .expect("expected EmptySpeakerName");

    workbench
        .apply_best_fix_for_issue(idx, false)
        .expect("autofix should apply");
    assert!(workbench.revert_last_fix());

    let Some(StoryNode::Dialogue { speaker, .. }) = workbench.node_graph.get_node(dialogue) else {
        panic!("expected dialogue node");
    };
    assert_eq!(speaker, "");
}

#[test]
fn no_silent_mutations_trace() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Linea".to_string(),
        },
        egui::pos2(0.0, 100.0),
    );
    workbench.node_graph.connect(start, dialogue);
    let _ = workbench.run_dry_validation();

    let idx = workbench
        .validation_issues
        .iter()
        .position(|issue| issue.code == LintCode::EmptySpeakerName)
        .expect("expected EmptySpeakerName");

    workbench
        .apply_best_fix_for_issue(idx, false)
        .expect("autofix should apply");
    let last = workbench
        .quick_fix_audit
        .last()
        .expect("quick-fix must be audited");
    assert_ne!(last.before_crc32, last.after_crc32);
    assert!(!last.diagnostic_id.is_empty());
    assert!(!last.fix_id.is_empty());
}

#[test]
fn language_switch_persistence() {
    let config = VnConfig::default();
    let mut source = EditorWorkbench::new(config.clone());
    source.diagnostic_language = crate::editor::DiagnosticLanguage::En;
    source.player_locale = "es".to_string();
    source
        .validation_issues
        .push(crate::editor::validator::LintIssue::warning(
            None,
            crate::editor::ValidationPhase::Graph,
            crate::editor::LintCode::MissingStart,
            "Missing Start node",
        ));

    let payload = source
        .diagnostic_report_json()
        .expect("report should serialize");

    let mut target = EditorWorkbench::new(config);
    target
        .apply_diagnostic_report_json(&payload)
        .expect("report should import");
    assert_eq!(
        target.diagnostic_language,
        crate::editor::DiagnosticLanguage::En
    );
    assert_eq!(target.player_locale, "es");
}

#[test]
fn apply_revert_fix_flow() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);
    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 100.0),
    );
    workbench.node_graph.connect(start, dialogue);
    let _ = workbench.run_dry_validation();

    let idx = workbench
        .validation_issues
        .iter()
        .position(|issue| issue.code == LintCode::EmptySpeakerName)
        .expect("expected EmptySpeakerName");
    workbench
        .apply_issue_fix(idx, "dialogue_fill_speaker")
        .expect("fix must apply");
    assert!(workbench.revert_last_fix());
}

#[test]
fn debug_panel_flow() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 0.0),
    );
    let _ = workbench.run_dry_validation();
    assert!(!workbench.validation_issues.is_empty());

    workbench.selected_issue = workbench
        .validation_issues
        .iter()
        .position(|issue| issue.code == LintCode::MissingStart);
    workbench.selected_node = Some(dialogue);
    assert!(workbench.selected_issue.is_some());
    assert_eq!(workbench.selected_node, Some(dialogue));
}

#[test]
fn sync_graph_keeps_validation_panel_closed_for_warnings_only() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    let start = workbench
        .node_graph
        .add_node(StoryNode::Start, egui::pos2(0.0, 0.0));
    let dialogue = workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 100.0),
    );
    let end = workbench
        .node_graph
        .add_node(StoryNode::End, egui::pos2(0.0, 200.0));
    workbench.node_graph.connect(start, dialogue);
    workbench.node_graph.connect(dialogue, end);

    let _ = workbench.run_dry_validation();
    assert!(workbench.show_validation);
    assert!(workbench
        .validation_issues
        .iter()
        .all(|issue| issue.severity != LintSeverity::Error));

    workbench.show_validation = false;
    let _ = workbench.sync_graph_to_script();
    assert!(
        !workbench.show_validation,
        "warnings should not force-open validation panel after manual close"
    );
}

#[test]
fn sync_graph_reopens_validation_panel_on_errors() {
    let config = VnConfig::default();
    let mut workbench = EditorWorkbench::new(config);

    workbench.node_graph.add_node(
        StoryNode::Dialogue {
            speaker: "Narrador".to_string(),
            text: "Hola".to_string(),
        },
        egui::pos2(0.0, 0.0),
    );

    workbench.show_validation = false;
    let _ = workbench.sync_graph_to_script();
    assert!(
        workbench.show_validation,
        "blocking errors must force-open validation panel"
    );
    assert!(workbench
        .validation_issues
        .iter()
        .any(|issue| issue.severity == LintSeverity::Error));
}
